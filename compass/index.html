<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:og="http://ogp.me/ns#" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <link rel="apple-touch-icon-precomposed" href="/colorwheel180.png">
  <link rel="icon" href="/colorwheel196.png">
  <meta property="og:title" content="The SpinWheel" />
  <meta property="og:type" content="website" />
  <meta property="og:description" content="Children have the natural curiosity and capacity to engineer a better world. Our kits just remind them." />
  <meta property="og:image" content="https://spinwearables.com/hanging.jpg" />
  <link rel="image_src" href="https://spinwearables.com/hanging.jpg" />
  <meta name="keywords" content="magnetism, compass" />
  <title>Make a Compass</title>
  <style>
  </style>
  <style>
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="/custom.css" />
  <link rel="stylesheet" href="/custom_book.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
<!-- Matomo -->
<script type="text/javascript">
  var _paq = window._paq || [];
  /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
  _paq.push(['trackPageView']);
  _paq.push(['enableLinkTracking']);
  (function() {
    var u="//matomo.spinwearables.com/";
    _paq.push(['setTrackerUrl', u+'matomo.php']);
    _paq.push(['setSiteId', '1']);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.type='text/javascript'; g.async=true; g.defer=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
  })();
</script>
<!-- End Matomo Code -->
</head>
<body>
<!-- Matomo Image Tracker-->
<noscript><img src="https://matomo.spinwearables.com/matomo.php?idsite=1&amp;rec=1" style="border:0" alt="" /></noscript>
<!-- End Matomo -->
<header>
<div class="nav">
<a href="/">The SpinWheel</a>
 | 
<a href="/book">The Field Guide</a>
</div>
<img src="/images/banners/compass.png">
<h1 class="title">Make a Compass</h1>
</header>
<main>
<div class="intro-box">
<p>By detecting Earth’s magnetic field, the SpinWheel can act as a compass. However, just as an old-school compass with a magnetic needle can be confused if you put it near a piece of iron, so does the magnetic sensor inside of the SpinWheel can give incorrect results. Here we will see how to write a program that calibrates against this error, the same type of program that runs inside of smartphone apps when they give you directions.</p>
</div>
<p>Making a compass is in principle as easy as making <a href="/tilt">the tilt sensor</a>. Just use the magnetic field <code>mx, my</code> instead of the gravitational field <code>ax, ay</code>. That way the display of the SpinWheel will point along the direction of Earth’s magnetic field, giving us a North/South orientation. This is analogous to how the tilt sensor showed us the direction of gravity, letting us know if a surface is flat.</p>
<p>However, our SpinWheel device might have many components near its sensor, that create <span style="color:#9266bc;"><strong>a spurrious magnetic field</strong></span>, causing confusion. Instead of measuring only <span style="color:#d42c2b;"><strong>Earth’s magnetic field</strong></span>, the sensor will measure both <span style="color:#d42c2b;"><strong>Earth’s field</strong></span>, and <span style="color:#9266bc;"><strong>the field created by objects near the sensor</strong></span>. Using this <strong>total measured magnetic field</strong> would result in a bad imprecise compass, therefore we need to find a way to remove <span style="color:#9266bc;"><strong>the spurrious field</strong></span> and be left only with <span style="color:#d42c2b;"><strong>Earth’s field</strong></span>.</p>
<p>This is a problem every smartphone manufacturer also faces. All of the metallic components inside of such a device might have their own magnetic fields, as well as temporary magnetization caused by various other objects, like keys kept in the same pocket. This is why pathfinding apps might ask you to shake your phone along a figure “8”, before they provide directions. We will see why these apps have such a requirement.</p>
<p>The main insight is that <span style="color:#9266bc;"><strong>the spurrious field</strong></span> is always present and fixed with respect to the sensor. If we rotate the sensor, that component of the measured result will not be changed. However, such a rotation would cause <span style="color:#d42c2b;"><strong>Earth’s field</strong></span> to be oriented differently with respect to the sensor, causing different values along each axis of the sensor. We can use this to our advantage! By rotating the device in complete circles, we can average out <span style="color:#d42c2b;"><strong>the external field</strong></span> leaving only <span style="color:#9266bc;"><strong>the field caused by the device itself</strong></span>. Having that value saved, we can now subtract it from future measurements, thus leaving us only with the desired result: <span style="color:#d42c2b;"><strong>Earth’s field</strong></span>.</p>
<p>Below you can see a simulation of such a series of measurement. The SpinWheel rotates in space, making constant measurements (each measurement is represented by a black dot). The <span style="color:#d42c2b;"><strong>external field, due to Earth’s magnetic field, i.e. the red vector</strong></span> is fixed. The <span style="color:#9266bc;"><strong>spurrious field caused by the device itself, i.e. the smaller purple vector</strong></span>, rotates with the SpinWheel. Their sum, the black vector is what we actually measure.</p>
<style>
.threediv {
  text-align: center;
  width: 100%;
  font-size: 0.9rem;
}
.threediv > * {
  display: block;
  margin: auto;
}
.threediv > p {
  width:400px;
}
.threediv > p > span {
  font-weight:var(--font-weight-strong);
}
</style>
<div id="threediv" class="threediv">
<p>
The SpinWheel from the point of view of an outside observer:
</p>
<div id="threejsanim" class="threejsanim">

</div>
<p>
The Magnetic fields with respect to the SpinWheel (i.e. from the SpinWheel’s point of view):
</p>
<div id="threejsanim2" class="threejsanim">

</div>
Tilt back and forth:<input id="fbtilt" type="range" min="-100" max="+100" value="30">Tilt sideways:<input id="lrtilt" type="range" min="-100" max="+100">Rotate face:<input id="frotate" type="range" min="-100" max="+100">
<div>
<button id="clearsphere">
Clear Points
</button>
<button id="autorot">
Autorotate
</button>
</div>
<p>
The three axes of the SpinWheel are colored as <span style="color:#92bd80;">X</span>, <span style="color:#8fb0d3;">Y</span>, and <span style="color:#f58559;">Z</span>. Also colored are the <span style="color:#d42c2b;">external magnetic field we want to measure</span>, <span style="color:#111111;">the total field that the sensor directly measures</span>, and the <span style="color:#9266bc;">magnetic field caused by the metalic SpinWheel components that causes the difference</span>.
</p>
</div>
</style>
<script type="module">

import * as THREE from '/three/three.module.js';

import { OrbitControls } from '/three/OrbitControls.js';
 
function makeSpinWheel() {
  var outerbox = new THREE.Group();
  var box = new THREE.Group();
  var geometry = new THREE.CylinderGeometry(20,20,1,24);
  var material = new THREE.MeshPhongMaterial({color: 0x111111, transparent: true, opacity: 0.90});
  var disk = new THREE.Mesh( geometry, material );
  box.add(disk);
  var sgeometry = new THREE.CylinderGeometry(1.5,1.5,1,24);
  var sdisk = new THREE.Mesh( sgeometry, material );
  sdisk.position.set(21/1.414,0,21/1.414);
  box.add(sdisk);
  for (var i=0; i<4; i++) {
    var bgeometry = new THREE.BoxGeometry(5,1.5,5);
    var wmaterial = new THREE.MeshPhongMaterial({color: 0xbbbbbb});
    var square1 = new THREE.Mesh(bgeometry, wmaterial);
    var square2 = new THREE.Mesh(bgeometry, wmaterial);
    var x = (-1)**i;
    var z = (-1)**(i>>1);
    square1.position.set(x*10,1.25,z*10);
    square2.position.set(x*3,1.25,z*3);
    //square1.rotation.z += Math.PI/2;
    box.add(square1);
    box.add(square2);
  }
  box.rotation.y = Math.PI*3/4;
  outerbox.add(box);
  return outerbox;
}

function makeScene(dogrid=true) {
  var scene = new THREE.Scene();
  scene.background = new THREE.Color( 0xffffff );

  var lights = [];
  lights[ 0 ] = new THREE.PointLight( 0xaaaaaa, 1, 0 );
  lights[ 1 ] = new THREE.PointLight( 0xaaaaaa, 1, 0 );
  lights[ 2 ] = new THREE.PointLight( 0xaaaaaa, 1, 0 );
  lights[ 0 ].position.set( 0, 200, 100 );
  lights[ 1 ].position.set( 0, 0, 100 );
  lights[ 2 ].position.set( 0, - 200, 100 );
  
  scene.add( lights[ 0 ] );
  scene.add( lights[ 1 ] );
  scene.add( lights[ 2 ] );

  if (dogrid==true) {
    var grid = new THREE.GridHelper( 1500, 70 );
    grid.position.set(0,-100,0);
    scene.add(grid);
  }

  return scene;
}

var camera, scene, renderer;
var camera2, scene2, renderer2;
var box;
const size = 400;
const animdiv = document.getElementById('threejsanim');
const animdiv2 = document.getElementById('threejsanim2');
const fgtilt = document.getElementById('fbtilt');
const lrtilt = document.getElementById('lrtilt');
const frotate = document.getElementById('frotate');

var Boutnormal = new THREE.Vector3(1,2,0.5).normalize();
var Bout = Boutnormal.clone().multiplyScalar(40);
var Binnormal = new THREE.Vector3(1,0.1,2).normalize();
var Bin = Binnormal.clone().multiplyScalar(12);
var Boutarrow2;
var Btotarrow2;
var pointcloudgeom;
var MAXPOINTS = 10000
var pointsarray = new Float32Array(3*MAXPOINTS);
var pointslen = 0;
var newpoint = false;

fgtilt.addEventListener('input', function (){newpoint=true;clearInterval(intervalid);})
lrtilt.addEventListener('input', function (){newpoint=true;clearInterval(intervalid);})
frotate.addEventListener('input', function (){newpoint=true;clearInterval(intervalid);})

function init() {
  scene = makeScene();
  
  box = makeSpinWheel();
  scene.add(box);

  for (var i = 1; i<=5; i++) {
    for (var j = 1; j<=5; j++) {
      var Boutarrow = new THREE.ArrowHelper(
        Boutnormal,
        new THREE.Vector3(i*40-120,0,j*40-120),
        40, 0xd42c2b,
        5, 2
      );
      scene.add(Boutarrow);
    }
  }

  var Binarrow = new THREE.ArrowHelper(
    Binnormal,
    new THREE.Vector3(0,2,0),
    12, 0x9266bc,
    5, 2
  );
  box.add(Binarrow);

  var xarrow = new THREE.ArrowHelper(
    new THREE.Vector3(1,0,0),
    new THREE.Vector3(0,2,0),
    25, 0x92bd80,
    0, 4
  );
  box.add(xarrow);

  var yarrow = new THREE.ArrowHelper(
    new THREE.Vector3(0,0,-1),
    new THREE.Vector3(0,2,0),
    25, 0x8fb0d3,
    0, 4
  );
  box.add(yarrow);

  var zarrow = new THREE.ArrowHelper(
    new THREE.Vector3(0,1,0),
    new THREE.Vector3(0,2,0),
    25, 0xf58559,
    0, 4
  );
  box.add(zarrow);

  var fov = 60;
  var aspect = 2;
  var near = 0.10;
  var far = 500;
  camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
  camera.position.z = 80;
  
  renderer = new THREE.WebGLRenderer( { antialias: true } );
  renderer.setSize( size, size/2 );
  animdiv.appendChild( renderer.domElement );

  var controls = new OrbitControls(camera, renderer.domElement);
}

function init2() {
  scene2 = makeScene(false);
  
  var xarrow = new THREE.ArrowHelper(
    new THREE.Vector3(1,0,0),
    new THREE.Vector3(0,0,0),
    25, 0x92bd80,
    0, 4
  );
  scene2.add(xarrow);

  var yarrow = new THREE.ArrowHelper(
    new THREE.Vector3(0,0,-1),
    new THREE.Vector3(0,0,0),
    25, 0x8fb0d3,
    0, 4
  );
  scene2.add(yarrow);

  var zarrow = new THREE.ArrowHelper(
    new THREE.Vector3(0,1,0),
    new THREE.Vector3(0,0,0),
    25, 0xf58559,
    0, 4
  );
  scene2.add(zarrow);

  Boutarrow2 = new THREE.ArrowHelper(
    Boutnormal,
    Bin,
    40, 0xd42c2b,
    5, 2
  );
  scene2.add(Boutarrow2);

  Btotarrow2 = new THREE.ArrowHelper(
    Boutnormal,
    new THREE.Vector3(0,0,0),
    0, 0x111111,
    5, 2
  );
  scene2.add(Btotarrow2);

  var Binarrow = new THREE.ArrowHelper(
    Binnormal,
    new THREE.Vector3(0,0,0),
    12, 0x9266bc,
    5, 2
  );
  scene2.add(Binarrow);

  pointcloudgeom = new THREE.BufferGeometry();
  var pcmaterial = new THREE.PointsMaterial( {size: 1, color: 0x111111} );
  var points = new THREE.Points(pointcloudgeom, pcmaterial);
  scene2.add(points);

  var fov = 60;
  var aspect = 2;
  var near = 0.10;
  var far = 500;
  camera2 = new THREE.PerspectiveCamera(fov, aspect, near, far);
  camera2.position.z = 50;
  camera2.position.y = 50;
  camera2.position.x = 50;
  
  renderer2 = new THREE.WebGLRenderer( { antialias: true } );
  renderer2.setSize( size, size/2 );
  animdiv2.appendChild( renderer2.domElement );

  var controls = new OrbitControls(camera2, renderer2.domElement);
}
 
function animate() {
  requestAnimationFrame( animate );
  const fb = fbtilt.value*Math.PI/2/100;
  const lr = lrtilt.value*Math.PI/2/100;
  const r = frotate.value*Math.PI/2/100;
  const euler = new THREE.Euler(fb,r,lr,'ZXY');
  box.setRotationFromEuler(euler);
  const quat = new THREE.Quaternion();
  const inverted = quat.setFromEuler(euler).conjugate();

  var localBoutnormal = Boutnormal.clone().applyQuaternion(inverted);
  Boutarrow2.setDirection(localBoutnormal);
  var localBtot = localBoutnormal.multiplyScalar(40).add(Bin);
  Btotarrow2.setLength(localBtot.length(), 5, 2);
  Btotarrow2.setDirection(localBtot.clone().normalize());

  if (newpoint) {
    pointsarray[3*pointslen] = localBtot.x;
    pointsarray[3*pointslen+1] = localBtot.y;
    pointsarray[3*pointslen+2] = localBtot.z;
    pointslen = (pointslen+1)%MAXPOINTS;
    pointcloudgeom.setAttribute('position', new THREE.BufferAttribute(pointsarray.subarray(0,3*pointslen), 3));
    pointcloudgeom.computeBoundingBox();
    newpoint = false;
  }

  renderer.render( scene, camera );
  renderer2.render( scene2, camera2 );
}
 
init();
init2();
animate();

var dir = 1;
function autoincrement() {
  if (fbtilt.valueAsNumber>=100) {
    fbtilt.valueAsNumber-=200;
  }  
  if (lrtilt.valueAsNumber>=100) {
    dir = -1;
    fbtilt.valueAsNumber+=11;
  }
  if (lrtilt.valueAsNumber<=-100) {
    dir = +1;
    fbtilt.valueAsNumber+=11;
  }
  lrtilt.valueAsNumber=lrtilt.valueAsNumber+6*dir;
  newpoint=true;
}

var intervalid = setInterval(autoincrement, 50);

const bautorot = document.getElementById('autorot');
const bclearsphere = document.getElementById('clearsphere');

bautorot.addEventListener('click', function (){
  clearInterval(intervalid);
  intervalid = setInterval(autoincrement, 50);
})
bclearsphere.addEventListener('click', function (){
  pointslen = 0;
  newpoint = true;
})

</script>
<p>You can see that the cloud of measurements creates a sphere, but one not centered at the <span class="math inline">\((0,0,0)\)</span> point. Rather, the center of this sphere is the tip of the <span style="color:#9266bc;"><strong>purple vector, the spurrious field</strong></span>. We will see a simple procedure we can use to find that center and subtract it from all future measurements.</p>
<h2 id="reading-magnetic-measurements-from-the-spinwheel">Reading Magnetic Measurements from The SpinWheel</h2>
<p>But first, let us actually perform some measurements on our SpinWheel. The code below, which can also be found in <a href="/codedoc/examples/Compass/Calibrate/Calibrate.ino.html"><code>Examples → SpinWearables → Compass →  Calibrate</code></a>, will take direct measurements from the magnetic sensor and immediately send them back to the host computer over the USB cable. On the host computer you can use the <code>Serial Plotter</code> Arduino tool tool, to observe how the values change as you rotate the device.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="pp">#include </span><span class="im">&quot;SpinWearables.h&quot;</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">using</span> <span class="kw">namespace</span> SpinWearables; </span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="dt">void</span> setup() {</span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="co">// Ensure all of the SpinWheel hardware is on.</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>  SpinWheel.begin();</span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="co">// Set up communication with the host computer.</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>  Serial.begin(<span class="dv">9600</span>);</span>
<span id="cb1-9"><a href="#cb1-9"></a>}</span>
<span id="cb1-10"><a href="#cb1-10"></a></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="dt">void</span> loop() {</span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="co">// Read all sensor data.</span></span>
<span id="cb1-13"><a href="#cb1-13"></a>  SpinWheel.readIMU();</span>
<span id="cb1-14"><a href="#cb1-14"></a></span>
<span id="cb1-15"><a href="#cb1-15"></a><span class="co">// Measure the magnetic field along the three axes of the sensor.</span></span>
<span id="cb1-16"><a href="#cb1-16"></a>  <span class="dt">float</span> x = SpinWheel.mx;</span>
<span id="cb1-17"><a href="#cb1-17"></a>  <span class="dt">float</span> y = SpinWheel.my;</span>
<span id="cb1-18"><a href="#cb1-18"></a>  <span class="dt">float</span> z = SpinWheel.mz;</span>
<span id="cb1-19"><a href="#cb1-19"></a></span>
<span id="cb1-20"><a href="#cb1-20"></a><span class="co">// Report it back to the host computer.</span></span>
<span id="cb1-21"><a href="#cb1-21"></a>  Serial.print(x);</span>
<span id="cb1-22"><a href="#cb1-22"></a>  Serial.print(<span class="st">&quot;</span><span class="sc">\t</span><span class="st">&quot;</span>); <span class="co">// Print a tab separator.</span></span>
<span id="cb1-23"><a href="#cb1-23"></a>  Serial.print(y);</span>
<span id="cb1-24"><a href="#cb1-24"></a>  Serial.print(<span class="st">&quot;</span><span class="sc">\t</span><span class="st">&quot;</span>); <span class="co">// Print a tab separator.</span></span>
<span id="cb1-25"><a href="#cb1-25"></a>  Serial.print(z);</span>
<span id="cb1-26"><a href="#cb1-26"></a>  Serial.print(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>); <span class="co">// Print a new line.</span></span>
<span id="cb1-27"><a href="#cb1-27"></a>}</span></code></pre></div>
<p>You can also use the <code>Serial Monitor</code> tool to copy the data and analyse it in a software of your choosing (a spreadsheet processor for instance). You can also simply copy the data in the text field below, to have it plotted directly in the browser. Currently that text field contains real data we observed with one of the first SpinWheels ever manufactured. If you rotate the plot (by dragging over it), you can clearly see that the sphere of measurements is not at all centered at the origin. Rather there is an offset that we have to correct for.</p>
<div id="pointclouddiv" class="threediv">
<div id="pointcloudanim" class="threejsanim">

</div>
<textarea id="pointcloudtext"></textarea>
</div>
<style>
#pointcloudtext {
  width: 200px;
  min-height: 100px;
}
</style>
<script type="module">

import * as THREE from '/three/three.module.js';

import { OrbitControls } from '/three/OrbitControls.js';
 
function makeScene() {
  var scene = new THREE.Scene();
  scene.background = new THREE.Color( 0xffffff );

  var lights = [];
  lights[ 0 ] = new THREE.PointLight( 0xaaaaaa, 1, 0 );
  lights[ 1 ] = new THREE.PointLight( 0xaaaaaa, 1, 0 );
  lights[ 2 ] = new THREE.PointLight( 0xaaaaaa, 1, 0 );
  lights[ 0 ].position.set( 0, 200, 100 );
  lights[ 1 ].position.set( 0, 0, 100 );
  lights[ 2 ].position.set( 0, - 200, 100 );
  
  scene.add( lights[ 0 ] );
  scene.add( lights[ 1 ] );
  scene.add( lights[ 2 ] );

  return scene;
}

var camera, scene, renderer;
var pointcloudgeom;
const size = 400;
const animdiv = document.getElementById('pointcloudanim');
   
function init() {
  scene = makeScene();
  
  var xarrow, yarrow, zarrow;

  xarrow = new THREE.ArrowHelper(
    new THREE.Vector3(1,0,0),
    new THREE.Vector3(0,0,0),
    70, 0x92bd80,
    10, 2
  );
  scene.add(xarrow);

  yarrow = new THREE.ArrowHelper(
    new THREE.Vector3(0,1,0),
    new THREE.Vector3(0,0,0),
    70, 0x8fb0d3,
    10, 2
  );
  scene.add(yarrow);

  zarrow = new THREE.ArrowHelper(
    new THREE.Vector3(0,0,1),
    new THREE.Vector3(0,0,0),
    70, 0xf58559,
    10, 2
  );
  scene.add(zarrow);

  pointcloudgeom = new THREE.BufferGeometry();
  processData();
  var pcmaterial = new THREE.PointsMaterial( {size: 1, color: 0x111111} );
  var points = new THREE.Points(pointcloudgeom, pcmaterial);
  scene.add(points);
  
  var fov = 60;
  var aspect = 2;
  var near = 0.10;
  var far = 500;
  camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
  camera.position.z = 80;
  camera.position.x = 80;
  camera.position.y = 80;
  
  renderer = new THREE.WebGLRenderer( { antialias: true } );
  renderer.setSize( size, size/2 );
  animdiv.appendChild( renderer.domElement );

  var controls = new OrbitControls(camera, renderer.domElement);
}
 
function animate() {
  requestAnimationFrame( animate );
  renderer.render( scene, camera );
}

function processData() {
  var array = new Float32Array;
  array = Float32Array.from(document.getElementById("pointcloudtext").value.replaceAll('\n','\t').replaceAll(' ', '\t').split('\t'));
  pointcloudgeom.setAttribute('position', new THREE.BufferAttribute(array, 3));
  pointcloudgeom.computeBoundingBox();
}
 
fetch('/data/compass.txt')
  .then(response => response.text())
  .then(function (data) {
    document.getElementById("pointcloudtext").value = data;
    init();
    animate();
  });

document.getElementById("pointcloudtext").addEventListener('input', processData);
</script>
<h2 id="compass-with-automatic-calibration">Compass with automatic calibration</h2>
<p>This leads us to the last step before having a functional compass. Instead of recording all of this data and preprocessing it in order to find the corrections we need to put to our measurements, we can instruct the SpinWheel to continuously correct itself. Initially, such an automatic correction will be significantly off, but after a few seconds of playing with the device, it would have measured enough data in order to correct itself.</p>
<p>The main insight here, is that we can store the maximal and minimal measurement value for each axis of the magnetometer. Then we use these maxima and minima, to find the offset of the sphere along each axis, and correct for it.</p>
<p>The code below, does exactly this. You can also find it in <a href="/codedoc/examples/Compass/Calibrate/Calibrate.ino.html"><code>Examples → SpinWearables → Compass →  Calibrated_Compass</code></a>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="dt">float</span> minx, miny, minz, maxx, maxy, maxz;</span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="dt">void</span> loop() {</span>
<span id="cb2-4"><a href="#cb2-4"></a>  <span class="co">// Read all sensor data.</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>  SpinWheel.readIMU();</span>
<span id="cb2-6"><a href="#cb2-6"></a></span>
<span id="cb2-7"><a href="#cb2-7"></a>  <span class="co">// Measure the magnetic field along the three axes of the sensor.</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>  <span class="dt">float</span> x = SpinWheel.mx;</span>
<span id="cb2-9"><a href="#cb2-9"></a>  <span class="dt">float</span> y = SpinWheel.my;</span>
<span id="cb2-10"><a href="#cb2-10"></a>  <span class="dt">float</span> z = SpinWheel.mz;</span>
<span id="cb2-11"><a href="#cb2-11"></a></span>
<span id="cb2-12"><a href="#cb2-12"></a>  <span class="cf">if</span> (x &gt; maxx) maxx=x;</span>
<span id="cb2-13"><a href="#cb2-13"></a>  <span class="cf">if</span> (y &gt; maxy) maxy=y;</span>
<span id="cb2-14"><a href="#cb2-14"></a>  <span class="cf">if</span> (z &gt; maxz) maxz=z;</span>
<span id="cb2-15"><a href="#cb2-15"></a>  <span class="cf">if</span> (x &lt; minx) minx=x;</span>
<span id="cb2-16"><a href="#cb2-16"></a>  <span class="cf">if</span> (y &lt; miny) miny=y;</span>
<span id="cb2-17"><a href="#cb2-17"></a>  <span class="cf">if</span> (z &lt; minz) minz=z;</span>
<span id="cb2-18"><a href="#cb2-18"></a></span>
<span id="cb2-19"><a href="#cb2-19"></a>  <span class="dt">float</span> truex = x - (maxx+minx)/<span class="dv">2</span>;</span>
<span id="cb2-20"><a href="#cb2-20"></a>  <span class="dt">float</span> truey = y - (maxy+miny)/<span class="dv">2</span>;</span>
<span id="cb2-21"><a href="#cb2-21"></a>  <span class="dt">float</span> truez = z - (maxz+minz)/<span class="dv">2</span>;</span>
<span id="cb2-22"><a href="#cb2-22"></a></span>
<span id="cb2-23"><a href="#cb2-23"></a>  <span class="co">// Use this line if you want to skip the correction.</span></span>
<span id="cb2-24"><a href="#cb2-24"></a>  <span class="co">//uint8_t angle = (-atan2(y, x)+3.1415/2)/2/3.1415*255;</span></span>
<span id="cb2-25"><a href="#cb2-25"></a>  <span class="dt">uint8_t</span> angle = (-atan2(truey, truex)+<span class="fl">3.1415</span>/<span class="dv">2</span>)/<span class="dv">2</span>/<span class="fl">3.1415</span>*<span class="dv">255</span>;</span>
<span id="cb2-26"><a href="#cb2-26"></a>  SpinWheel.setSmallLEDsPointer(angle, <span class="dv">800</span>, <span class="bn">0xffffff</span>);</span>
<span id="cb2-27"><a href="#cb2-27"></a></span>
<span id="cb2-28"><a href="#cb2-28"></a>  SpinWheel.drawFrame();</span>
<span id="cb2-29"><a href="#cb2-29"></a>}</span></code></pre></div>
<p>Compared to the <a href="/tilt">tilt sensor</a>, there is little more to it than the lines like:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a>  <span class="cf">if</span> (x &gt; maxx) maxx=x;</span>
<span id="cb3-2"><a href="#cb3-2"></a>  <span class="cf">if</span> (y &gt; maxy) maxy=y;</span>
<span id="cb3-3"><a href="#cb3-3"></a></span>
<span id="cb3-4"><a href="#cb3-4"></a>  <span class="dt">float</span> truex = x - (maxx+minx)/<span class="dv">2</span>;</span></code></pre></div>
<p>Here we continuously update the maximal and minimal values ever measured, and then use them to correct the current measurement result.</p>
<p>We will leave it to you to mix together the tilt and compass sensors, for after all, a good compass needs a tilt sensor that lets you know if you are indeed measuring only the horizontal component of Earth’s magnetic field.</p>
<p><a class="imagecredit" href="https://johnhegarty8.wixsite.com/johnhegarty">Header image credit: Jack Hegarty</a></p>
<script data-isso="//comments.spinwearables.com/"
data-isso-reply-to-self="false"
data-isso-require-author="true"
data-isso-require-email="true"
data-isso-avatar="false"
data-isso-vote="false"
src="//comments.spinwearables.com/js/embed.min.js"></script>
<section id="isso-thread"></section>
<script>
document.querySelector("#isso-thread").addEventListener(
  "click",
  function () {
    document.querySelectorAll("#isso-thread > div").forEach(function (x) {x.style.display = "block";});
  });
</script>
</main>
<div id="license">
<!--<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="/cc-by-sa.png" /></a> This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.-->
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="/cc-by-nc-sa.png" /></a></a> This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>. © SpinWearables LLC (<a href="/license">license and trademark details</a>)
</div>
</body>
</html>
